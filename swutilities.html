<!DOCTYPE html>
<html>
  <head>
    <meta content="text/html; charset=UTF-8" http-equiv="content-type">
    <title>swutilities</title>
    <meta content="Andy Heilveil" name="author">
  </head>
  <body>
    <p>Andy's raspberry pi programming utilities<br>
      many of these work with any linux or many posix systems.</p>
    <ol>
      <li>uses mmap based access to GPIO's, syntactically as booleans.</li>
      <li>epoll support, but it fails miserably with corrupted callbacks on the pi, worked fine on an x64 system.</li>
      <li>usb bulk access via libusb, with c++ stuff to ensure release of resources</li>
      <li>ftdi2232h and related MPSSE access, usb access to spi. Might be partially entrained in a module particular to one use of that device.</li>
      <li>background file read with callback on completion, or on each block if you wish</li>
      <li>background file write, see background read.</li>
      <li>telnet multiconnection server, event driven polling (either you monitor fd's or poll)</li>
      <li>com port configuration (baud etc.)</li>
      <li>systemd used for auto-running an application </li>
      <ol>
        <li>scripts demonstrating access to logging and syntax of start/stop etc.</li>
        <li>installation script, there is a lot of wrong stuff on the internet in this area.</li>
      </ol>
      <li>two file installer, script and zip file. </li>
      <li>Amptek XRF DP5 and MiniX devices.</li>
    </ol>
    <p>general system stuff, dynamic memory used (malloc() and new )</p>
    <ol>
      <li>DOM with change detection callback lists</li>
      <ol>
        <li>template class wrapping of DOM scalars so that they appear as their native type</li>
        <li>pathname access to members</li>
        <li>template class wrapping of DOM arrays with deletion and insertion watchers</li>
        <li>array coupling, where a dependent array is resized to match correlated deletions and insertions in a master array</li>
        <ol>
          <li>pre-deletion veto</li>
        </ol>
      </ol>
      <li>json parsing and printing</li>
      <ol>
        <li>abstractly, push bytes at parser, it returns pairs of stream indexes of content. caller decides where string data comes from and parsed data goes to.</li>
        <li>concrete implementation that reads byte array and fills the aforementioned DOM</li>
      </ol>
      <li>template based printf</li>
      <ol>
        <li>for argument safety</li>
        <li>attempts minimal heap activity (estimates and mallocs once)</li>
      </ol>
      <li>minimal logging system, </li>
      <ol>
        <li>printf formatting (with all the risks thereof)</li>
        <li>multiple logger sources each with boolean enable. Can create separate entities for different levels such as info/warn/error.</li>
        <li>ability on most systems to emit a stack trace on demand.</li>
      </ol>
      <li>container managed lifetime for objects that must be allocated from the heap.</li>
      <ol>
        <li>provides much std::vector functionality, but with java-like syntax, for instance...</li>
        <li>... iterator with bool hasNext() and Obj&amp; next() api.</li>
      </ol>
      <li>class that makes char* act like an object</li>
      <ol>
        <li>str functions as member:&nbsp;&nbsp; text.cat(othertext) instead of strcat(text, othertext)</li>
        <li>transfer of ownership variation (makes it easy to not leak, or use-after-free)</li>
      </ol>
      <li>class that makes char act like an object</li>
      <ol>
        <li>c.isWhite(), c.isNumeral()</li>
      </ol>
      <li>UTF8 support</li>
      <ol>
        <li>utf8 as 32 bit unsigned, with object syntax ( utf8.isAscii(), utf8.numFollowers() {returns size in a bytestream;})</li>
        <li>to and from byte stream, via push parsing </li>
      </ol>
      <li>textified enumerations</li>
      <li>timer service</li>
      <ol>
        <li>multiple logical timers, fed by one 'real' timer.</li>
      </ol>
      <li>templated stack with autopop assistant</li>
      <ol>
        <li>far cheaper than stl version, far fewer features</li>
        <li>TOS syntactially accessed as if a scalar variable</li>
        <li>has 'pusher' object that pushes stack on creation, pops it on deletion making it easy to not unbalance your stack </li>
      </ol>
      <li>saturating counters</li>
      <ol>
        <li>don't count down past zero.</li>
      </ol>
      <li>buffer pointer</li>
      <ol>
        <li>that won't go outside of buffer (unless you lie about buffer size when you create it, there are macros to avoid this, working on 'real code' to prevent it)</li>
        <li>but does NOT manage buffer lifetime</li>
        <li>many utility functions</li>
        <li>java-like iteration</li>
      </ol>
    </ol>
    <p>microcontroller compatible stuff (no dynamic memory allocation)</p>
    <ol>
      <li>many variations of 'set variable on exit of scope', useful for things like releasing a mutex or 'post increment' on a non-native type.</li>
      <li>state based number parsing and printing</li>
      <li>macros and linker support for building tables of entities in ROM, including dispatch tables or callback lists.</li>
      <li>for many microcontrollers </li>
      <ol>
        <li>access GPIO syntactically as booleans</li>
        <li>template computation of hardware register addresses, resolves to minimal machine code for access.</li>
      </ol>
    </ol>
  </body>
</html>
